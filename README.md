<img src="https://www.prmry.io/static/prmry.png" width="244"/>


#### PRMRY AI Hub for prompt engineering interaction management.


<!-- TOC -->

* [Local deployment](#local-deployment)
* [Design](#design)
* [Components](#components)
* [Resources](#resources)
* [Contributing](#contributing)
<!-- TOC -->

## Local deployment

*Requires Go 1.20*

1. Create a .env file and configure the app:
   ```shell
   cp .env.example .env
   ``` 
   See here for info about getting Github and Google [oauth credentials](docs/oauth.md).
2. Spin up the docker containers to start MySQL and NGINX.
   ```shell
   docker-compose up -d
   ```
3. Once the DB is initialized, and you see "ready for connections" in the mysql container logs, run the DB migrations:
   ```shell
   ./scripts/goose.sh up
   ```
4. Run the app:
   
   *either* using the wrapper scripts (**watch.sh** will restart the process if any **.templ** file changes): 
   ```
   ./scripts/server.sh
   
   # OR
   
   ./scripts/watch.sh
   ```
   **watch.sh** will restart the process if a **.templ** file changes.  In both cases the scripts run: 
   ```shell
   templ generate && go run ./cmd/htmx-server
   ```
   
#  Design
This application renders HTML markup server-side, using the [Templ templating language](https://templ.guide/) to define components which are (_very_) loosely similar to React components. 

Interactivity and SPA behavior are achieved with HTMX, an extension to HTML that extends its capabilities via certain `hx-*` attributes, allowing a component's behavior to be defined directly in the HTML markup.  

For example to trigger a `GET` request from a button click, a button element could be defined like: 
```html
<button hx-get="/do-something" hx-trigger="click">
  Do Something
</button>
```

More about the hypertext-focused design in the [Resources](#resources) below.

### Components
Components live in the [components](internal/components) package, and are defined by 3 files:
* **domain.go** - contains view model structs, which are used to pass data to a template. Each view model must implement `components.Component` 
* **domain.templ** - contains template definitions. 
* **domain_templ.go** - contains go code generated by the `templ generate` command (which is run automatically by the wrapper script).

The view model for the "Account" page is defined in **components/account/account.go**:
```go
type ProfileView struct {
	Provider  string
	Email     string
	Name      string
	AvatarURL string
	components.BaseComponent
}
```

The components are defined in [profile.templ](internal/components/profile/profile.templ).  Templ allows us to compose templates, so for the full-page component, the _Profile_ component is composed inside the _Page_ component (defined in [page.templ](internal/components/page.templ)):
```html
templ Profile(view ProfileView) {
  <div>
    Hello { view.Name }, your id is { view.ID }.
  </div>
}

templ ProfilePage(view ProfileView) {
  @Page(&view) {
    @Profile(view)
  }
}
```


### Resources

- [HTMX](https://htmx.org/docs/)
- [Locality of Behavior (LoB)](https://htmx.org/essays/locality-of-behaviour/)
- [Islands Architecture](https://github.com/bensmithett/tropical-utils/tree/main/packages/tropical-islands) / [discussion](https://www.patterns.dev/posts/islands-architecture)
- [HATEOAS](https://htmx.org/essays/hateoas/)
- [Templ Templating](https://templ.guide/)
- [Chi HTTP Router](https://github.com/go-chi/chi)

## Contributing
Please contribute using [Github Flow](https://guides.github.com/introduction/flow/). Create a branch, add commits, and [open a pull request](https://github.com/fraction/readme-boilerplate/compare/).
